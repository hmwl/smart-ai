console.log('Script starting...');
require('dotenv').config({ path: require('path').resolve(__dirname, '.env') });
console.log('dotenv configured. MONGODB_URI:', process.env.MONGODB_URI ? 'Loaded' : 'NOT LOADED');

const mongoose = require('mongoose');
const Work = require('./models/Work'); // Adjust path if necessary
const Tag = require('./models/Tag');   // Adjust path if necessary

async function backfillTags() {
  const mongoConnectionString = process.env.MONGODB_URI;
  if (!mongoConnectionString) {
    console.error('ERROR: MONGODB_URI was not found in .env file.');
    process.exit(1);
  }

  try {
    await mongoose.connect(mongoConnectionString);
    console.log('MongoDB connected successfully for backfill script.');

    const allWorks = await Work.find({ tags: { $exists: true, $ne: [] } }).select('tags');
    if (!allWorks || allWorks.length === 0) {
      console.log('No works found with tags. Exiting.');
      return;
    }

    const uniqueTagNames = new Set();
    allWorks.forEach(work => {
      if (work.tags && Array.isArray(work.tags)) {
        work.tags.forEach(tagName => {
          if (typeof tagName === 'string' && tagName.trim() !== '') {
            uniqueTagNames.add(tagName.trim().toLowerCase());
          }
        });
      }
    });

    if (uniqueTagNames.size === 0) {
      console.log('No unique tag names found in works. Exiting.');
      return;
    }

    console.log(`Found ${uniqueTagNames.size} unique tag names to process:`, Array.from(uniqueTagNames));

    let createdCount = 0;
    let existingCount = 0;

    for (const tagName of uniqueTagNames) {
      try {
        const existingTag = await Tag.findOne({ name: tagName });
        if (existingTag) {
          console.log(`Tag "${tagName}" already exists with ID ${existingTag._id}. Skipping.`);
          existingCount++;
        } else {
          const newTag = new Tag({ name: tagName }); // The _id will be auto-generated by the model's default
          await newTag.save();
          console.log(`Created new tag "${tagName}" with ID ${newTag._id}.`);
          createdCount++;
        }
      } catch (error) {
        if (error.code === 11000) { // Duplicate key error
          console.warn(`Attempted to create duplicate tag "${tagName}", but it seems to exist (race condition or similar). Skipping.`);
          existingCount++; // Count it as existing if a duplicate error occurs
        } else {
          console.error(`Error processing tag "${tagName}":`, error.message);
        }
      }
    }

    console.log('\n--- Backfill Summary ---');
    console.log(`Total unique tag names found in works: ${uniqueTagNames.size}`);
    console.log(`New tags created in Tag collection: ${createdCount}`);
    console.log(`Tags that already existed in Tag collection: ${existingCount}`);
    
    const unhandledTags = uniqueTagNames.size - (createdCount + existingCount);
    if (unhandledTags > 0) {
        console.warn(`Number of tags that might not have been handled due to errors (check logs above): ${unhandledTags}`);
    }

  } catch (error) {
    console.error('Error during backfill process:', error);
  } finally {
    await mongoose.disconnect();
    console.log('MongoDB disconnected.');
  }
}

backfillTags(); 