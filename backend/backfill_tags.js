require('dotenv').config({ path: require('path').resolve(__dirname, '.env') });

const mongoose = require('mongoose');
const Work = require('./models/Work'); // Adjust path if necessary
const Tag = require('./models/Tag');   // Adjust path if necessary

async function backfillTags() {
  const mongoConnectionString = process.env.MONGODB_URI;
  if (!mongoConnectionString) {
    console.error('ERROR: MONGODB_URI was not found in .env file.');
    process.exit(1);
  }

  try {
    await mongoose.connect(mongoConnectionString);

    const allWorks = await Work.find({ tags: { $exists: true, $ne: [] } }).select('tags');
    if (!allWorks || allWorks.length === 0) {
      return;
    }

    const uniqueTagNames = new Set();
    allWorks.forEach(work => {
      if (work.tags && Array.isArray(work.tags)) {
        work.tags.forEach(tagName => {
          if (typeof tagName === 'string' && tagName.trim() !== '') {
            uniqueTagNames.add(tagName.trim().toLowerCase());
          }
        });
      }
    });

    if (uniqueTagNames.size === 0) {
      return;
    }


    let createdCount = 0;
    let existingCount = 0;

    for (const tagName of uniqueTagNames) {
      try {
        const existingTag = await Tag.findOne({ name: tagName });
        if (existingTag) {
          existingCount++;
        } else {
          const newTag = new Tag({ name: tagName }); // The _id will be auto-generated by the model's default
          await newTag.save();
          createdCount++;
        }
      } catch (error) {
        if (error.code === 11000) { // Duplicate key error
          console.warn(`Attempted to create duplicate tag "${tagName}", but it seems to exist (race condition or similar). Skipping.`);
          existingCount++; // Count it as existing if a duplicate error occurs
        } else {
          console.error(`Error processing tag "${tagName}":`, error.message);
        }
      }
    }

    
    const unhandledTags = uniqueTagNames.size - (createdCount + existingCount);
    if (unhandledTags > 0) {
        console.warn(`Number of tags that might not have been handled due to errors (check logs above): ${unhandledTags}`);
    }

  } catch (error) {
    console.error('Error during backfill process:', error);
  } finally {
    await mongoose.disconnect();
  }
}

backfillTags(); 